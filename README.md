# cgMSI
## cgMSI: pathogen detection within species from nanopore metagenomic sequencing data
### Introduction
cgMSI (Core Genome Metagenome Strain Identify), a tool to detect pathogen from nanopore metagenomic data within species at low abundance. 
 cgMSI consists of two core modules:
- The cgMSI LIB module will create or update the library accroding to the file provided by the user. 
- The cgMSI MAP module will  identify the strain and estimate the abundance.


### Support and Contact
For any issues or concerns, please contact us at zhuxu@stu.xmu.edu.cn
 

### Pathogenic Species Supported
Species name | Number of loci
-|-
Klebsiella pneumoniae | 2358
Escherichia coli| 2531
Enterococcus faecalis | 1972
Listeria monocytogenes | 1701
Pseudomonas aeruginosa | 3867
Staphylococcus aureus| 1861
Salmonella enterica | 3002
Proteus mirabilis | 1122

### Software Dependencies
It is recommended to create a new conda environment:
```
conda create -n python37 python=3.7

# Activate this environment:
conda activate python37
```
       • numpy (v1.15.0)
            conda install -c conda-forge numpy
       • pandas (v0.24.2)
            conda install -c conda-forge pandas
       • minimap2 (v2.24)
            conda install -c bioconda minimap2
       • pysam (v0.15.3)
            conda install -c bioconda pysam 
       • seqkit (v2.0.0)
            conda install -c bioconda seqkit 
            

### Manual
First of all, we should:
- change directory (cd) to cgMSI folder
- cd into cgMSI directory 
  ```
  cd ../cgMSI
  python cgMSI.py -h
  ```
#### LIB
We need the database of strains, which can be downloaded from NCBI. Also you can add your own genomes to the folder. First you need to make sure that 
genomes belonging to the same species are in one folder, different species are in different folders.  
create a new library for a species:
```
python cgMSI.py LIB -genomesDir genomeDIR -allelePath species_alleles.fasta -alleleTable speciesAlleleTable -species speciesName -t threadNumber 

Required arguments:

-genomesDir,              string                    Target species Reference Genome Directory Full Path 

-allelePath,              string                    alleles fasta file,can be download 

-alleleTable,             string                    

-species,                 string                  species name with No whitespace(if Escherichia coli ,like Ec) for distinguish different species


Optional arguments:

-t,                       int                    Number of threads to use by aligner (bowtie2) if different from default (8)
                    
```

add a genome to a existed species library:
```


```
#### MAP
First you need to make sure that the map module is finished. ID module will use file .sam generated previously with MAP module.

call snipeId module help for details

```
python snipe.py ID -h

python snipe.py ID -outDir id_outdir -alignFile id_ali_file -expTag id_exp_tag

Required arguments:

-alignFile,      string                    Alignment file path

-expTag,         string                    Experiment tag added to output file for easy identification

Optional arguments:

-outDir,         string                    Output Directory (Default=. (current directory))
```
#### REC
Make sure the SSRs index has been established.

call snipeRec module help for details

```
python snipe.py REC -h

python snipe.py REC -ssrRef map_ssrRefDir -1 rec_inputread1 -2 rec_inputread2 -idReport id_ali_file -dictTarget targetInfo_dict -dictTemplate file3 -outDir path2 -numThreads 1

Required arguments:

-ssrRef,         string                    the directory of the species specific regions

-1,              string                    Input Read Fastq File (Pair 1)

-2,              string                    Input Read Fastq File (Pair 2)

-idReport,       string                    alignment file generated by ID module

-dictTarget,     string                    the dict which contains accession id to species name

-dictTemplate,   string                    the dict which contains accession id to strain name

-expTag,         string                    Experiment tag added to output file for easy identification

Optional arguments:

-outDir,         string                    Output Directory (Default=.(current directory))

-numThreads,     int                       Number of threads to use default (1)

```

### Step-by-step example
#### 0. [Make sure you have all the ingredients]
```
bowtie2 --version
python -V
import pysam, pandas, numpy
pysam.__version__
pandas.__version__
numpy.__version__
```
#### 1. [The SnipeMap module]
```
python ./snipe/snipe.py MAP -1 example/demo_R1.fastp35.fastq -2 example/demo_R2.fastp35.fastq -targetRefFiles ./refDB/target.fna -filterRefFiles ./refDB/filter.fna -indexDir ./refDB/ -outDir ./ -outAlign demo.sam -expTag demo -numThreads 44
```
#### 2. [The SnipeID module]
```
python ./snipe/snipe.py ID -alignFile ./demo.sam -fileType sam -outDir ./ -expTag demo
```
#### 3. [The SnipeRec module]
```
python ./snipe/snipe.py REC -ssrRef ./core/ -1 ./example/demo_R1.fastp35.fastq -2 ./example/demo_R2.fastp35.fastq -idReport demo-sam-report.tsv -dictTarget ./dict/dict_target -dictTemplate ./dict/dict_template -expTag demo -outDir ./ -numThreads 44
```


### Output TSV file format
Columns in the TSV file:
#### 1.Genomes:
This is the name of the genome found in the alignment file.
#### 2.Accession ID:
Accession ID used by NCBI Genebank database.
#### 3.Rectified Final Guess:
This represents the percentage of reads that are mapped to the genome in Column 1 after using SSRs rectification.
#### 4.Final Guess:
This represents the percentage of reads that are mapped to the genome in Column 1 (reads aligning to multiple genomes are assigned proportionally) after reassignment is performed.
#### 5.Rectified Probability:
This represents probability after using SSRs rectification .
#### 6.SSR Aligned Reads:
This represents the number of reads that are mapped to the SSRs.
#### 7.Rectified Abundance:
This represents the abundance after using SSRs rectification.
#### 8.Initial Abundance:
This represents the abundance before using SSRs rectification.
#### 9.Final Best Hit:
This represents the percentage of reads that are mapped to the genome in Column 1 after assigning each read uniquely to the genome with the highest score and after pathoscope reassignment is performed.
#### 10.Final Best Hit Read Numbers:
This represents the number of best hit reads that are mapped to the genome in Column 1 (may include a fraction when a read is aligned to multiple top hit genomes with the same highest score) and after pathoscope reassignment is performed.
